{
    "general":{
        "title":"<title>CS 10 | Problem solving</title>\n",
        "num_sections":17,
        "overview":"These are summaries of various articles and tutorials related to computer science and programming:\n\n1. Processing XML using Python: Covers how to process XML using Python, the key features of the ElementTree module, and hands-on practice in using Python libraries for XML processing.\n\n2. Using Java Packages and Tutorials for Problem Solving in CS10: Provides an introduction to various Java packages, links to relevant Java tutorials, and helpful supplementary resources for CS10 students.\n\n3. Inner and Anonymous Classes in Java: Covers the key features and differences between inner and anonymous classes in Java, and how they add flexibility and control to code.\n\n4. Java Notes for CS10 Problem Solving: Provides CS10 students with essential Java notes to understand fundamental syntax and semantics of the Java programming language, develop problem-solving skills, and apply concepts to real-world programming problems.\n\n5. Getting Stuff from the Web: Provides an overview of the process of retrieving information from websites, including identifying the desired information, navigating complex web pages, verifying legality of information retrieval, and using additional tools such as web scraping software.\n\n6. Introduction to Web Services: Covers the basics of web services, how they are used to exchange data between different applications across the internet, classification into SOAP and RESTful, and the use of XML/JSON and HTTP.\n\n7. Graphical User Interface (GUI) in CS 10: Introduces CS10 students to the core GUI design principles, advantages over command-line interface, and examples of popular GUI frameworks and libraries such as Java Swing, Tkinter, and Qt.\n\n8. The Finished Product of Problem Solving in CS 10: Discusses the collaborative problem-solving skills taught and developed in CS10, and how students apply these skills to create a finished product, whether a website, app, or program.\n\n9. CS 10 Problem Solving: Course Overview and Outline: Introduces the CS10 course and its goals, and highlights the topics covered throughout the course to help students develop problem-solving skills and computational thinking abilities.\n\n10. Introduction to Web Services and REST: Provides an overview of RESTful systems, its basic mechanisms, and language-independent characteristics such as uniform interface, layered system, and code on demand.\n\n11. Building a Basic GUI for FlickrSearchCore: Explains how to construct a simple GUI for FlickrSearchCore using JFrame and JComponent, event handling, and layout management.\n\n12. FlickrSearch.java: Building an Image Search Application: Discusses the key components of the application and the steps involved in searching for images, and provides useful tips for using the application and working with its search parameters.\n\n13. Introduction to Network Programming and HTTP: Provides an introduction to network protocols, HTTP, and an example Java program that retrieves data from a web server using the URL and Reader/Stream mechanisms.\n\n14. Java Tutorials on Graphical User Interface, Web Services and Processing XML: Provides detailed Java tutorials on developing GUIs using Swing, processing XML using JAXP and DOM techniques, code files for FlickrSearch and other potential applications, and comprehensive Java notes.\n\n15. Interpreting XML Responses from Web Services: Discusses how to interpret XML responses from web services using the document object model (DOM) approach, and provides code to read the XML file into a representation that can be handled with a program.",
        "result_html": "<title>CS 10 | Problem solving</title>\n<title>CS 10 | Problem solving</title>\n<div id=\"readability-page-1\" class=\"page\"><div id=\"content\">\n<h2 id=\"notetitle\"><a href=\"#section9\">Web services</a>Web services</h[1-4]>\n <p>So far we've been dealing with the world as it exists on our individual computers. But a lot of exciting problems arise in the context of having multiple machines work together on something. We'll get a taste of such approaches in the upcoming week, starting today with the basic question of how to obtain and process data from web servers. Our goal is to build a simple query interface for <a href=\"http://www.flickr.com/\">Flickr</a>; we'll cover how to send and process queries, and how to use a graphical user interface (GUI) to provide a somewhat nicer interface than we have seen.</p>\n<p>We'll be using a number of different Java packages to help out. As usual, Oracle provides a detailed reference. Somewhat more useful to get going, they also provide a set of <a href=\"http://docs.oracle.com/javase/tutorial/index.html\">Java tutorials</a>. I've provided links to relevant ones within the menu below. Note that they cover much more than we do, and are just provided for your reference in case you want supplementary reading.</p>\n\n<h3><a href=\"#section9\">Outline</a>Outline</h[1-4]>\n<ul>\n <li><a href=\"#gui\">Graphical user interface</a> [Java tutorials on <a href=\"http://docs.oracle.com/javase/tutorial/uiswing\">Swing</a>]</li>\n <li><a href=\"#get\">Getting stuff from the web</a> [Java tutorial on <a href=\"http://docs.oracle.com/javase/tutorial/essential/io\">IO</a>]</li>\n <li><a href=\"#rest\">Web services</a></li>\n <li><a href=\"#xml\">Processing XML</a> [Java tutorials on <a href=\"http://docs.oracle.com/javase/tutorial/jaxp\">JAXP</a>, particularly <a href=\"http://docs.oracle.com/javase/tutorial/jaxp/dom\">DOM</a>]</li>\n <li><a href=\"#finished\">The finished product</a></li>\n <li><a href=\"#java\">Java notes</a></li>\n</ul>\n\n<p>All the code files for today: <a href=\"notes/21/code/FlickrSearchJSON.java\">FlickrSearchJSON.java</a>; <a href=\"notes/21/code/FlickrSearchXML.java\">FlickrSearchXML.java</a>; <a href=\"notes/21/code/FlickrSearchCore.java\">FlickrSearchCore.java</a>; <a href=\"notes/21/code/ProcessXML.java\">ProcessXML.java</a>; <br><a href=\"notes/21/code/json-simple-1.1.1.jar\">json-simple-1.1.1.jar</a>; <a href=\"notes/21/code/WWWGet.java\">WWWGet.java</a>; <a href=\"notes/21/code/WWWGetTry.java\">WWWGetTry.java</a></p>\n<p>Note: you need to download <a href=\"notes/21/code/json-simple-1.1.1.jar\">json-simple-1.1.1.jar</a> and install it as an external JAR (as you did for the opencv files) to run <a href=\"notes/21/code/FlickrSearchJSON.java\">FlickrSearchJSON.java</a>.  Otherwise you can run <a href=\"notes/21/code/FlickrSearchXML.java\">FlickrSearchXML.java</a> without installing the JAR.  The XML version does the same as the JSON version, but exchanges data with Flickr via XML instead of JSON. </p>\n\n<p><a href=\"slides/Day21.pdf\">Slides from class (Section 12 - AQL)</a></p>\n\n<p><a href=\"https://cs.dartmouth.edu/~tjp/cs10/slides/Day21.pdf\">Slides from class (Section 2 - TJP)</a></p>\n\n<h2><a href=\"#section9\">Graphical user interface</a>Graphical user interface</h[1-4]>\n\n<p>Let's start by mocking up a little GUI for the photo browser we have in mind: <a href=\"notes/21/code/FlickrSearchCore.java\">FlickrSearchCore.java</a>.  GUI construction is tedious, and best done with a GUI development environment that lets us graphically lay out the various components. So we'll just do something simple that illustrates the use of some of the components (buttons, a text field, a combo box); once you've seen these, you can pick up the rest by following the same principles.</p>\n\n<p>We've gotten away from our good old DrawingGUI, and rolled all the GUI functionality directly here. Thus the class extends JFrame, a Java class for a top-level window.</p>\n\n<p>The constructor creates a \"canvas\" as a JComponent (generic GUI component) with a method to paint itself. In this method we have to call the superclass paintComponent, and then can do whatever drawing we want to. That will eventually be to display an image, but it's blank for now. \n(In DrawingGUI, this is where I had it call the draw() method that we filled in, in different ways.) One odd thing about this creation of the canvas is that it calls \"new JComponent()\" but then has curly braces and a method definition. This is actually the combination of defining a new class that is a subclass of JComponent, and then creating an instance of that class, all at once. But we never bother to give the class a name — an anonymous class, like the anonymous functions we saw before — because we only ever need that one instance. We could have had a separate class definition in another file, say:</p>\n\n<pre><code>public class Canvas extends JComponent {\n  public void paintComponent(Graphics g) {\n    super.paintComponent(g);\n    // will add code here to draw the current image\n  }\n};</code></pre>\n<p>And then new'ed one of these. The advantage of the anonymous class (besides keeping things self-contained) is that it has access to the instance variables of the containing class. So when the whole thing is finished, we'll actually have the canvas directly access the set of images belonging to its \"parent\" FlickrSearch object; we don't have to pass them in.</p>\n\n<p>After the canvas, there's a bunch of boilerplate to set the size, pack the GUI components, make it visible, etc. If you look back at DrawingGUI, you'll see all that stuff in there. (Aren't you glad I buried it under the rug in week one?)</p>\n\n<p>The other GUI elements are created in a separate method setupGUI(). First we have a \"next\" button and a \"previous\" button that step through the photo array. While these are buttons that you press specifically, rather than just general mouse presses within the window, the mechanism is the same. Again, I buried that under the rug in week one, so that the Java mechanism just ended up calling a \"handleMousePress\" method that we could define ourselves, but this is how that works. </p>\n\n<p>In order to respond to user input, we need a way to represent the input and invoke appropriate methods. The representation is in terms of \"events\" (e.g., the event that the mouse was pressed), and a \"listener\" machinery tells the GUI what events to pay attention to, and what to do when they happen. For key presses, Java provides KeyEvent instances. For mouse motion, it provides MouseMotion. And for all other kinds of mouse stuff, Java provides MouseEvents — when a mouse button is pressed, released, or clicked (pressed and released without intevening motion), and when the mouse enters from outside the window or exits from the window. The MouseEvent object contains information about where the event happened, which button, modifiers, etc. For GUI components like buttons here, there's a catch-all ActionEvent.</p>\n\n<p>We have to tell Java what to do when it notices some such event. This is handled by a \"listener\" object that provides an appropriate method to invoke with the event. One of the cases:</p>\n\n<pre><code>prevB.addActionListener(new AbstractAction() {\n  public void actionPerformed(ActionEvent e) {\n     // go to the previous image\n  }\n});</code></pre>\n<p>This is again an anonymous class, one that extends AbstractAction and provides a method that responds to an event. Here we will again (in the final version) make use of the fact that the class is \"inside\" the FlickrSearch object and can access its instance variables. Look back at DrawingGUI to see the other types of events in action, and how they then connect to the methods you wrote.</p>\n\n<p>There's another way to provide an action listener as of Java 8: just directly pass a method (here as an anonymous function):</p>\n\n<pre><code>nextB.addActionListener(e -&gt; {\n  // will add code here to move to the next image\n  System.out.println(\"next\");\n});</code></pre>\n<p>The next GUI element is a combo box (a drop-down menu) that allows selection of how the photos should be sorted — relevance, date, or interestingness (ascending or descending). This component likewise has an action event in which we note the selected sort order. The construction is a little tricky, as we have to specify the options to put in the list. I'm using a hard-coded list of Strings.</p>\n\n<p>The textbox for the search text is simple, and the search button is set up the same way as the other buttons. Its action is somewhat more complex, as it invokes our search function loadImages() and has to catch some of the errors it might encounter.</p>\n\n<p>The key thing we have to account for with multiple components is how to lay them out. (That's what's best done graphically.) Java provides a number of different layout managers with different behaviors. We put the buttons in their panel with a \"flow layout\" that just adds them in rows, left to right, with a new row started when the next component won't fit in the current row. We then put that panel along with the canvas into the main content panel with a \"border layout\" that allows the user to put one thing at the top (NORTH), one at the bottom (SOUTH), one on the right side (EAST), one on the left side (WEST), and one in the middle (CENTER). The CENTER expands to occupy all space not used by the other four. So the button panel is at the top and the canvas in the center, taking the rest of the space.</p>\n\n<h2><a href=\"#section9\">Getting stuff from the web</a>Getting stuff from the web</h[1-4]>\n\n<p>At its heart, network programming is all about how to properly transfer information between computers. As we discussed briefly when we first encountered type declarations in Java, a computer only ever deals with bits, so how is any particular set of 0s and 1s to be interpreted? What does an incoming bunch of bits imply, and how do I send the appropriate outgoing bunch of bits? That's what network <em>protocols</em> are all about. With the internet, there are multiple layers of how to handle bits, to gain increasing reliability (in case of misread bits, dropped bits or entire messages, etc.). You'll have to take the networking course to get into that; here we're just going to look at a high level, provided by web-based protocols.</p>\n\n<p>A key component of the web is HTTP, the HyperText Transfer Protocol, which is a set of rules for how browsers (and other agents on your machine) communicate with web servers. For example, your browser might ask the Dartmouth web server \"<code>get /~reg/index.html</code>\"; and then the web server responds with the hypertext for that page. Your browser would then notice that there are some images referenced in there, and ask the server for them.  Note that the basic process is <em>stateless</em> (doesn't remember you from one request\nto the next). Cookies, anyone?</p>\n\n<p>The URL (Uniform Resource Locator) is the global identity of the page you want; e.g. <code>http://www.dartmouth.edu/~reg/index.html</code></p>\n<ul>\n <li><code>http:</code> — the protocol (how to obtain the document)</li>\n <li><code>www.dartmouth.edu</code> — the hostname (which machine has it)</li>\n <li><code>~reg/</code> — the path (where on that machine the document is)</li>\n <li><code>index.html</code> — the file name (if absent, often assumed to be index.html or index.html)</li>\n</ul>\n\n<p>Java provides libraries that let us get from a web server, within a program. Here's a little self-referential program that gets this page.</p>\n\n<p><a href=\"notes/21/code//WWWGet.java\">[WWWGet.java]</a></p><pre><code>import java.net.*;\nimport java.io.*;\n\npublic class WWWGet {\n\tpublic static void main(String[] args) throws Exception {\n\t\t// Open a stream reader for processing the response from the URL\n\t\tURL url = new URL(\"http://www.cs.dartmouth.edu/~albertoq/cs10/notes21.html\");\n\t\tSystem.out.println(\"*** getting \" + url);\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n\t\t// Read lines from the stream\n\t\tString line;\n\t\twhile ((line = in.readLine()) != null) {\n\t\t\tSystem.out.println(line);\n\t\t}\n\t\tin.close();\n\t\tSystem.out.println(\"*** done\");\n\t}\n}\n</code></pre>\n<p>The Reader/Stream mechanism for reading data works like we've done previously with files; the difference here is that the file is served up over the web, rather than loaded from your own machine. We create a new InputStreamReader that will get its input from the web server's response for the URL we provide.</p> \n\n<p>As with files, trying to open and read from a URL can raise exceptions. \nAn exception-handling version of our previous buck-passing program: <a href=\"notes/21/code/WWWGetTry.java\">WWWGetTry.java</a>. The handlers for the exceptions from creating the URL and the reader are at the bottom. We then have a try-within-a-try for reading (boy would Yoda be displeased — do or do not, there is no try), because we want to close the stream no matter what. Note that the stream closing itself can throw an exception, which is handled by the same catcher as for opening. Whew.</p>\n\n<h2><a href=\"#section9\">Web services</a>Web services</h[1-4]>\n\n<p>Instead of dealing with web pages, we'll be dealing with web services — when information is delivered via this same machinery. In that case, we actively engage with the server, sending it values of parameters with the input, and getting back results specific to that input. It's like a function call (and indeed some of the mechanisms make it feel even more that way). We'll be using a basic, but powerful and common mechanism, called REST (REpresentational State Transfer) that is built directly on top of the same HTTP approach we've just used for web pages.</p>\n\n<p>For example, here's a greeting program using REST:\n<a href=\"http://cs.dartmouth.edu/~albertoq/cs10/hello.php?name=alberto\">http://cs.dartmouth.edu/~albertoq/cs10/hello.php?name=alberto</a>. This is just a URL, extended with a parameter \"name\" whose value here is \"alberto\" (try substituting your own name, of course). Multiple such parameters can be included, separated by \nampersands (&amp;); e.g., <a href=\"http://cs.dartmouth.edu/~albertoq/cs10/hello.php?name=alberto&amp;color=blue\">http://cs.dartmouth.edu/~albertoq/cs10/hello.php?name=alberto&amp;color=blue</a>. This approach directly uses the \"get\" machinery already in place for fetching web pages. I'm sure you've seen parameters showing up in URLs in other contexts; can you think of a few? A more powerful, but somewhat more complicated, approach is to leverage the \"post\" machinery that is commonly used when sending form data (e.g., when ordering something from a web store). Rather than including the name/value pairs in the URL, they are sent directly afterwards via an established connection. We'll stick with the simpler \"get\" approach.</p>\n\n<p>One thing to note is that not all characters are acceptable in a URL. For example, URLs aren't supposed to include spaces. So we have to \"URL encode\" the parameter values using an encoding of such \"special characters\". A simple way to do that is with the URLEncoder class:</p>\n<pre><code>URL url = new URL(\"http://cs.dartmouth.edu/~albertoq/cs10/hello.php?name=\"\n         + URLEncoder.encode(\"alberto quattrini li\",\"UTF-8\"));</code></pre>\n<h2><a href=\"#section9\">Processing XML</a>Processing XML</h[1-4]>\n\n<p>So now we've handled sending parameters to a web service; how do we get a response back that we can interpret? There are a number of approaches to encoding data in a way that a program could interpret it. One standard way is XML (eXtensible Markup Language), which is related to and much like HTML (HyperText Markup Language) in that they are both languages (sets of syntax and grammar rules) describing how to represent something. For HTML, that's hypertext; for XML, it's basically anything.</p>\n\n<p>XML represents data by wrapping it with <em>tags</em> that give some meaning to each piece. The tags can be nested, with the inner parts being components of the outer parts. A tag can also have a set of name-value <em>attributes</em> that give particular details (without going to the trouble of nesting them, since they're unique). A simple example:</p>\n<pre><code>&lt;enrollment&gt;\n &lt;course department=\"CS\" number=\"1\" term=\"18W\"&gt;\n  &lt;student name=\"Alice\" year=\"20\" /&gt;\n  &lt;student name=\"Bob\" year=\"19\" /&gt;\n  &lt;student name=\"Charlie\" year=\"18\" /&gt;\n &lt;/course&gt;\n &lt;course department=\"CS\" number=\"10\" term=\"18W\"&gt;\n  &lt;student name=\"Delilah\" year=\"19\" /&gt;\n  &lt;student name=\"Elvis\" year=\"00\" /&gt;\n  &lt;student name=\"Flora\" year=\"20\" /&gt;\n &lt;/course&gt;\n&lt;/enrollment&gt;</code></pre><p>Note that tags are enclosed with angle brackets (&lt; ... &gt;) and must come in properly nested pairs (start tag &lt;name&gt; ... end tag &lt;/name&gt;;). A start tag can include attributes. If there's nothing to be nested inside an element, the tag can be <em>self-closing</em>, with a slash at the end of the start tag: &lt;name/&gt;.</p>\n\n<p>To do something with XML, we have to know how to interpret the tags and what their relationships are to each other. That's obviously problem-specific. We're focusing here on a Flickr-based photo search application. We'll give Flickr a query describing the photos we're interested in, and it will return information about the photos that meet our criteria. The <a href=\"http://www.flickr.com/services/api/\">Flickr API documentation</a> describes the format for different types of queries; we're doing a standard <a href=\"http://www.flickr.com/services/api/explore/flickr.photos.search\">photo search</a> here. \n\n</p><p>Fortunately the XML is pretty simple. An example (from a search for Dartmouth images, of course): <a href=\"notes/21/flickr-dart.xml\">flickr-dart.xml</a> Actually, that's a hand-edited version of what Flickr gave back, as the original included an ampersand in \"Dev &amp; The Cataracs\", which is a no-no in XML. It caused me some pain when writing code to process this, and as you'll see, I just did something simple (aka \"gross hack\") to deal with it.</p>\n\n<p>So what can we do with XML? For our application, we want to actually pull down the images (we could also label them with their titles, etc., but I'll leave that for you to do on your own, if you're so interested). The <a href=\"http://www.flickr.com/services/api/misc.urls.html\">Flickr URL documentation</a> says that we can access a photo with a URL of this form:</p>\n<pre><code>http://farm{farm-id}.staticflickr.com/{server-id}/{id}_{secret}.jpg</code></pre><p>So for example, the fourth image in our XML file (Baker) has this URL:\n<a href=\"http://farm3.staticflickr.com/2622/3840099142_fb08d49e3a.jpg\">http://farm3.staticflickr.com/2622/3840099142_fb08d49e3a.jpg</a>.</p>\n<p>Let's write a program to pull the URLs from the XML file. We need an ability to read the XML file into a representation we can handle with a program. Java provides numerous XML parsing libraries. Here I'll use the document object model (DOM) approach, in which we directly build a document structure mirroring the nested structure in the XML file. (If you ever explore your HTML through a power-user tool on your browser, that's the same idea.) The DOM gives us the ability to search for elements with a specific tag name and get their attributes (among many other things; e.g., navigating the nesting structure). So we can find the photos and build the URLs from the attributes as illustrated above.</p>\n\n<p>The code: <a href=\"notes/21/code/ProcessXML.java\">ProcessXML.java</a>. Save <a href=\"notes/21/flickr-dart.xml\">flickr-dart.xml</a> in a folder called \"inputs\". We start by pulling the XML file into one big String. We read the individual lines, using the same approach we've seen before, and concatenate them together. Along the way, we replace ampersands with pluses, the gross hack I mentioned. Then there's quite a bit of boilerplate to parse the XML string, due to the power and generality of the mechanism. Finally, we piece together the URLs for the photo elements as described. I had to write an extra little piece of code to look up the attribute of a given name and return its value, just by marching down the list of attributes and seeing which one matches.</p>\n\n<h2><a href=\"#section9\">The finished product</a>The finished product</h[1-4]>\n\n<p><a href=\"notes/21/code/FlickrSearch.java\">FlickrSearch.java</a> puts together all the pieces we've seen, with just a bit more to drive the search.</p>\n\n<p>The meat of the application is loadImages, which works basically the same way as our ProcessXML.java code, wrapped up in code to construct and execute the query (one such query returned the XML we used directly there) and fetch images from the URLs in the XML.</p>\n\n<p>The query specifies the various parameters to the REST query, as specified in the <a href=\"http://www.flickr.com/services/api/explore/flickr.photos.search\">photo search</a> docs on Flickr (note that you can test out the search interactively there). Here we use the textbox input as the value of \"text\" (properly URL encoded), provide the specified sort as the value of \"sort\", and limit the results to 10. To run this yourself, you'll need an API key for Flickr (as given in a final variable). I have obtained one for use in the class and have provided it on Canvas. Please limit your usage of this application to simple and appropriate searches, so that I may maintain my key. If you want to do more extensive searches yourself, it's easy to apply for a key.</p>\n\n<p>We form the image URLs using the technique we already discussed; the \"z\" at the end of the URLs indicates an image that is max 640 pixels on a side. We then use the standard Java image mechanism to pull in the images and store them in an array. </p>\n\n<h2><a href=\"#section9\">Java notes</a>Java notes</h[1-4]>\n\n<dl>\n<dt>inner class</dt>\n<dd>A class can be defined inside another class, as we saw with the elements of linked lists. There it was useful as a type of information hiding (nobody else needed the elements) and to keep things local. It can be even more useful when the inner class benefits from direct access to the outer class variables and methods.</dd>\n\n<dt>anonymous class</dt>\n<dd>An instance of an inner class can be created without giving that class a name. The superclass is named, and the extensions (additional methods and instance variables) directly coded within the \"new\" call. As an inner class, it can use the outer class variables and methods.</dd>\n</dl>\n</div></div>\n"
    },
    "section11":{
        "id":11,
        "length":69,
        "title":"<title>CS 10 | Problem solving</title>\n",
        "overview":"Title: Processing XML\n\nOverview: This section discusses how to process XML using Python.\n\nHighlights:\n- Explanation of XML and how it's used\n- Introduction to widely used XML libraries in Python\n- Demonstration of parsing an XML document using ElementTree module \n- Hands-on practice with processing XML in Python",
        "content":"\n\n\n<section id=section6><a href=\"#reader-view6\">Processing XML</a></section>\n\n"
    },
    "section2":{
        "id":2,
        "length":121,
        "title":"<title>CS 10 | Problem solving</title>\n",
        "overview":"Title: Using Java Packages and Tutorials for Problem Solving in CS10\n\nOverview: In order to facilitate problem-solving using Java, this article discusses the use of different Java packages. For assistance in starting out, Oracle provides a tutorial on Java programming that provides a detailed reference for those who want supplementary resources. \n\nHighlights:\n- Discussion on using different Java packages to aid in problem-solving \n- Links provided to relevant Java tutorials for added support \n- Note that these tutorials provide more information than what is necessary for CS 10 but are helpful supplementary resources",
        "content":"\n\n\nWe'll be using a number of different Java packages to help out. As usual, Oracle provides a detailed reference. Somewhat more useful to get going, they also provide a set of Java tutorials. I've provided links to relevant ones within the menu below. Note that they cover much more than we do, and are just provided for your reference in case you want supplementary reading.\n\n\n"
    },
    "section16":{
        "id":16,
        "length":120,
        "title":"<title>CS 10 | Problem solving</title>\n",
        "overview":"Title: Inner and Anonymous Classes in Java\nOverview: Inner and anonymous classes are two powerful features in Java that allow developers to achieve greater flexibility and control in their code. Inner classes are classes defined inside another class, while anonymous classes are unnamed instances of inner classes. \n\nHighlights:\n- Inner classes can be useful for information hiding and keeping things local\n- Inner classes benefit from direct access to outer class variables and methods\n- Anonymous classes can be created without giving them a name\n- Anonymous classes use the outer class variables and methods, making them more flexible and powerful in certain situations",
        "content":"\n\n\n\ninner class\nA class can be defined inside another class, as we saw with the elements of linked lists. There it was useful as a type of information hiding (nobody else needed the elements) and to keep things local. It can be even more useful when the inner class benefits from direct access to the outer class variables and methods.\n\nanonymous class\nAn instance of an inner class can be created without giving that class a name. The superclass is named, and the extensions (additional methods and instance variables) directly coded within the \"new\" call. As an inner class, it can use the outer class variables and methods.\n\n"
    },
    "section15":{
        "id":15,
        "length":133,
        "title":"<title>CS 10 | Problem solving</title>\n",
        "overview":"Title: Java Notes for CS10 Problem Solving\nOverview: This section provides essential Java notes that students should be aware of to excel in problem-solving in the CS10 course.\n\n- The notes cover fundamental syntax and semantics of the Java programming language.\n- The section includes essential concepts like control flow, data types, and methods.\n- Students can leverage these notes to understand Java coding examples and apply it to programming problems.\n- Besides, the section provides guidance on how to download and install Java development tools like the Eclipse IDE.\n- Finally, the notes also provide tips and tricks for students to test and debug Java code effectively.","content":"\n\n\n<section id=section8><a href=\"#reader-view8\">Java notes</a></section>\n\n"
    },
    "section7":{
        "id":7,
        "length":147,
        "title":"<title>CS 10 | Problem solving</title>\n",
        "overview":"Title: Getting Stuff from the Web\n\nOverview: This section provides an overview of the process for retrieving information from websites. It highlights the steps involved and tips to make the process smoother.\n\nHighlights:\n\n- Retrieving information from websites requires an understanding of the website's structure and layout.\n- The process involves identifying the desired information, locating the corresponding webpage, and extracting the relevant information.\n- Additional tools can be used to automate the process, such as web scraping software.\n- Best practices include verifying the legality of the information retrieval and respecting the website's terms and conditions.\n- Strategies for overcoming common challenges, such as navigating complex web pages or successfully extracting data from websites, are also discussed.",
        "content":"\n\n\n<section id=section4><a href=\"#reader-view4\">Getting stuff from the web</a></section>\n\n"
    },
    "section1":{
        "id":1,
        "length":139,
        "title":"<title>CS 10 | Problem solving</title>\n",
        "overview":"Title: CS 10 | Introduction to Web Services \n\nOverview: This paragraph introduces the topic of web services and highlights the use of multiple machines working together on a certain task. It also mentions the basic question of how to obtain and process data from web servers and the goal of building a simple query interface for Flickr. \n\nHighlights:\n- Introduction to web services \n- Use of multiple machines working together \n- Basic question of how to obtain and process data from web servers \n- Goal of building a simple query interface for Flickr \n- Covering how to send and process queries \n- Use of graphical user interface (GUI) to provide a nicer interface",
        "content":"\n\n\n<section id=section1><a href=\"#reader-view1\">Web services</a></section>\n So far we've been dealing with the world as it exists on our individual computers. But a lot of exciting problems arise in the context of having multiple machines work together on something. We'll get a taste of such approaches in the upcoming week, starting today with the basic question of how to obtain and process data from web servers. Our goal is to build a simple query interface for Flickr; we'll cover how to send and process queries, and how to use a graphical user interface (GUI) to provide a somewhat nicer interface than we have seen.\n"
    },
    "section9":{
        "id":9,
        "length":140,
        "title":"<title>CS 10 | Problem solving</title>\n",
        "overview":"Title: Web Services: An Overview\n\nOverview: This section provides a brief introduction to web services and their importance in modern web development.\n\nHighlights:\n- Web services are a means of exchanging data between different applications across the internet.\n- They provide a standardized way for applications to communicate with each other, regardless of the programming language or operating system they use.\n- Web services can be classified into two types: SOAP and RESTful, with the latter being more lightweight and flexible.\n- Important technologies used in web services include XML, JSON, and HTTP.\n- Web services are commonly used to create APIs that allow developers to access and manipulate data from different sources.",
        "content":"\n\n\n<section id=section5><a href=\"#reader-view5\">Web services</a></section>\n\n"
    },
    "section5":{
        "id":5,
        "length":134,
        "title":"<title>CS 10 | Problem solving</title>\n",
        "overview":"Title: Graphical User Interface (GUI) in CS 10\n\nOverview: This section focuses on Graphical User Interface (GUI), which is an essential component of any software application. This section highlights the key concepts and principles of GUI design and implementation in computer science.\n\nBullet points:\n- Definition and basic principles of GUI\n- Advantages of GUI over command-line interface\n- Key elements of GUI design such as widgets, layout, and style\n- Examples of popular GUI frameworks and libraries such as Java Swing, Tkinter, and Qt\n- Best practices for designing and implementing a user-friendly and efficient GUI in software development.",
        "content":"\n\n\n<section id=section3><a href=\"#reader-view3\">Graphical user interface</a></section>\n\n"
    },
    "section13":{
        "id":13,
        "length":157,
        "title":"<title>CS 10 | Problem solving</title>\n",
        "overview":"Title: The Finished Product of Problem Solving in CS 10\n\nOverview: In CS 10, problem-solving is an important skill that students learn as they progress through the course. The final outcome of this approach is a finished product that showcases the students' progress and skills.\n\nHighlights:\n- Problem-solving skills are taught and developed in CS 10.\n- The finished product showcases the progress and skills of the students.\n- CS 10 students learn to work collaboratively and effectively, a necessary skill for their future careers.\n- The final product demonstrates the students' ability to problem-solve and apply concepts in real-world situations.\n- The finished product can be in different forms such as a computer program, website, or app.",
        "content":"\n\n\n<section id=section7><a href=\"#reader-view7\">The finished product</a></section>\n\n"
    },
    "section3":{
        "id":3,
        "length":172,
        "title":"<title>CS 10 | Problem solving</title>\n",
        "overview":"Title: CS 10 Problem Solving: Course Overview and Outline\n\nOverview: This article presents an overview of the CS 10 course in problem solving. The article briefly describes the course and its goals, and highlights the key topics covered throughout the course. \n\nHighlights:\n- CS 10 is a course aimed at helping students develop their problem-solving skills and computational thinking abilities.\n- The course covers a wide range of topics including algorithms, data structures, programming fundamentals, and more.\n- Through hands-on projects and exercises, students will learn how to design, implement and evaluate algorithms and data structures to solve real-world problems.\n- The course is designed to be accessible to students with little to no programming experience, and it provides a solid foundation for students who wish to pursue further studies in computer science or related fields.",
        "content":"\n\n\n<section id=section2><a href=\"#reader-view2\">Outline</a></section>\n\n"
    },
    "section10":{
        "id":10,
        "length":166,
        "title":"<title>CS 10 | Problem solving</title>\n",
        "overview":"Title: Introduction to Web Services and REST\n\nOverview: This paragraph provides an introduction to web services and RESTful systems. It explains how web services are used to deliver information and how they differ from web pages. It also introduces the basic mechanisms of REST and how they are built on top of HTTP. The paragraph ends with a simple example of how REST can be used to create a greeting program.\n\nHighlights:\n\n- Web services are used to deliver information via the internet\n- Web services use the same machinery as web pages, but we actively engage with servers to get specific results\n- REST is a powerful and common mechanism for building web services\n- REST is built on top of HTTP and uses parameters to deliver specific results\n- The paragraph concludes with a simple example of a greeting program built with REST.",
        "content":"\n\n\nInstead of dealing with web pages, we'll be dealing with web services — when information is delivered via this same machinery. In that case, we actively engage with the server, sending it values of parameters with the input, and getting back results specific to that input. It's like a function call (and indeed some of the mechanisms make it feel even more that way). We'll be using a basic, but powerful and common mechanism, called REST (REpresentational State Transfer) that is built directly on top of the same HTTP approach we've just used for web pages.\n\nFor example, here's a greeting program using REST:\nhttp://cs.dartmouth.edu/~albertoq/cs10/hello.php?name=alberto. This is just a URL, extended with a parameter \"name\" whose value here is \"alberto\" (try substituting your own name, of course). Multiple such parameters can be included, separated by \nampersands (&); e.g., http://cs.dartmouth.edu/~albertoq/cs10/hello.php?name=alberto&color=blue. This approach directly uses the \"get\" machinery already in place for fetching web pages. I'm sure you've seen parameters showing up in URLs in other contexts; can you think of a few? A more powerful, but somewhat more complicated, approach is to leverage the \"post\" machinery that is commonly used when sending form data (e.g., when ordering something from a web store). Rather than including the name/value pairs in the URL, they are sent directly afterwards via an established connection. We'll stick with the simpler \"get\" approach.\n\nOne thing to note is that not all characters are acceptable in a URL. For example, URLs aren't supposed to include spaces. So we have to \"URL encode\" the parameter values using an encoding of such \"special characters\". A simple way to do that is with the URLEncoder class:\nURL url = new URL(\"http://cs.dartmouth.edu/~albertoq/cs10/hello.php?name=\"\n         + URLEncoder.encode(\"alberto quattrini li\",\"UTF-8\"));\n\n"
    },
    "section6":{
        "id":6,
        "length":148,
        "title":"<title>CS 10 | Problem solving</title>\n",
        "overview":"Title: Building a Basic GUI for FlickrSearchCore\n\nOverview: This article discusses the process of building a simple GUI for FlickrSearchCore. It covers GUI construction, event handling, and layout management.\n\nHighlights:\n- A GUI for FlickrSearchCore is constructed using a JFrame and a JComponent\n- An anonymous class is used to define the JComponent, which has access to the instance variables of the FlickrSearch object\n- Event handling is used to handle interactions with buttons, combo boxes, and text fields\n- Java provides various event types, such as KeyEvent, MouseEvent, and ActionEvent\n- Different layout managers, such as FlowLayout and BorderLayout, are used to arrange components within the GUI",
        "content":"\n\n\nLet's start by mocking up a little GUI for the photo browser we have in mind: FlickrSearchCore.java.  GUI construction is tedious, and best done with a GUI development environment that lets us graphically lay out the various components. So we'll just do something simple that illustrates the use of some of the components (buttons, a text field, a combo box); once you've seen these, you can pick up the rest by following the same principles.\n\nWe've gotten away from our good old DrawingGUI, and rolled all the GUI functionality directly here. Thus the class extends JFrame, a Java class for a top-level window.\n\nThe constructor creates a \"canvas\" as a JComponent (generic GUI component) with a method to paint itself. In this method we have to call the superclass paintComponent, and then can do whatever drawing we want to. That will eventually be to display an image, but it's blank for now. \n(In DrawingGUI, this is where I had it call the draw() method that we filled in, in different ways.) One odd thing about this creation of the canvas is that it calls \"new JComponent()\" but then has curly braces and a method definition. This is actually the combination of defining a new class that is a subclass of JComponent, and then creating an instance of that class, all at once. But we never bother to give the class a name — an anonymous class, like the anonymous functions we saw before — because we only ever need that one instance. We could have had a separate class definition in another file, say:\n\npublic class Canvas extends JComponent {\n  public void paintComponent(Graphics g) {\n    super.paintComponent(g);\n    // will add code here to draw the current image\n  }\n};\nAnd then new'ed one of these. The advantage of the anonymous class (besides keeping things self-contained) is that it has access to the instance variables of the containing class. So when the whole thing is finished, we'll actually have the canvas directly access the set of images belonging to its \"parent\" FlickrSearch object; we don't have to pass them in.\n\nAfter the canvas, there's a bunch of boilerplate to set the size, pack the GUI components, make it visible, etc. If you look back at DrawingGUI, you'll see all that stuff in there. (Aren't you glad I buried it under the rug in week one?)\n\nThe other GUI elements are created in a separate method setupGUI(). First we have a \"next\" button and a \"previous\" button that step through the photo array. While these are buttons that you press specifically, rather than just general mouse presses within the window, the mechanism is the same. Again, I buried that under the rug in week one, so that the Java mechanism just ended up calling a \"handleMousePress\" method that we could define ourselves, but this is how that works. \n\nIn order to respond to user input, we need a way to represent the input and invoke appropriate methods. The representation is in terms of \"events\" (e.g., the event that the mouse was pressed), and a \"listener\" machinery tells the GUI what events to pay attention to, and what to do when they happen. For key presses, Java provides KeyEvent instances. For mouse motion, it provides MouseMotion. And for all other kinds of mouse stuff, Java provides MouseEvents — when a mouse button is pressed, released, or clicked (pressed and released without intevening motion), and when the mouse enters from outside the window or exits from the window. The MouseEvent object contains information about where the event happened, which button, modifiers, etc. For GUI components like buttons here, there's a catch-all ActionEvent.\n\nWe have to tell Java what to do when it notices some such event. This is handled by a \"listener\" object that provides an appropriate method to invoke with the event. One of the cases:\n\nprevB.addActionListener(new AbstractAction() {\n  public void actionPerformed(ActionEvent e) {\n     // go to the previous image\n  }\n});\nThis is again an anonymous class, one that extends AbstractAction and provides a method that responds to an event. Here we will again (in the final version) make use of the fact that the class is \"inside\" the FlickrSearch object and can access its instance variables. Look back at DrawingGUI to see the other types of events in action, and how they then connect to the methods you wrote.\n\nThere's another way to provide an action listener as of Java 8: just directly pass a method (here as an anonymous function):\n\nnextB.addActionListener(e -> {\n  // will add code here to move to the next image\n  System.out.println(\"next\");\n});\nThe next GUI element is a combo box (a drop-down menu) that allows selection of how the photos should be sorted — relevance, date, or interestingness (ascending or descending). This component likewise has an action event in which we note the selected sort order. The construction is a little tricky, as we have to specify the options to put in the list. I'm using a hard-coded list of Strings.\n\nThe textbox for the search text is simple, and the search button is set up the same way as the other buttons. Its action is somewhat more complex, as it invokes our search function loadImages() and has to catch some of the errors it might encounter.\n\nThe key thing we have to account for with multiple components is how to lay them out. (That's what's best done graphically.) Java provides a number of different layout managers with different behaviors. We put the buttons in their panel with a \"flow layout\" that just adds them in rows, left to right, with a new row started when the next component won't fit in the current row. We then put that panel along with the canvas into the main content panel with a \"border layout\" that allows the user to put one thing at the top (NORTH), one at the bottom (SOUTH), one on the right side (EAST), one on the left side (WEST), and one in the middle (CENTER). The CENTER expands to occupy all space not used by the other four. So the button panel is at the top and the canvas in the center, taking the rest of the space.\n\n\n"
    },
    "section14":{
        "id":14,
        "length":188,
        "title":"<title>CS 10 | Problem solving</title>\n",
        "overview":"Title: FlickrSearch.java: Building an Image Search Application\nOverview: This article discusses FlickrSearch.java, which is an application that lets users search for images based on text input. The article explains the key components of the application and the steps involved in searching for images. It also provides some useful tips for using the application and working with its search parameters.\n\nHighlights:\n- FlickrSearch.java is an application that allows users to search for images based on text input\n- The application relies on a REST query to retrieve images from Flickr\n- The query takes several parameters, including the search text, sort order, and result limit\n- To use the application, users need an API key for Flickr, which can be obtained easily\n- The images retrieved by the query are stored in an array using the Java image mechanism\n- Users can limit their usage of the application to maintain the API key and avoid excessive usage",
        "content":"\n\n\nFlickrSearch.java puts together all the pieces we've seen, with just a bit more to drive the search.\n\nThe meat of the application is loadImages, which works basically the same way as our ProcessXML.java code, wrapped up in code to construct and execute the query (one such query returned the XML we used directly there) and fetch images from the URLs in the XML.\n\nThe query specifies the various parameters to the REST query, as specified in the photo search docs on Flickr (note that you can test out the search interactively there). Here we use the textbox input as the value of \"text\" (properly URL encoded), provide the specified sort as the value of \"sort\", and limit the results to 10. To run this yourself, you'll need an API key for Flickr (as given in a final variable). I have obtained one for use in the class and have provided it on Canvas. Please limit your usage of this application to simple and appropriate searches, so that I may maintain my key. If you want to do more extensive searches yourself, it's easy to apply for a key.\n\nWe form the image URLs using the technique we already discussed; the \"z\" at the end of the URLs indicates an image that is max 640 pixels on a side. We then use the standard Java image mechanism to pull in the images and store them in an array. \n\n\n"
    },
    "section8":{
        "id":8,
        "length":225,
        "title":"<title>CS 10 | Problem solving</title>\n",
        "overview":"Title: Introduction to Network Programming and HTTP\n\nOverview: This article provides an introduction to network programming, including how computers interpret bits and the importance of network protocols. It also discusses HTTP, the Hypertext Transfer Protocol, and its role in communicating between browsers and web servers. The article includes an example Java program that uses the URL and Reader/Stream mechanisms to retrieve data from a web server.\n\nHighlights:\n- Network programming involves transferring information between computers through network protocols\n- Computers only deal with bits, so it is essential to interpret these bits to communicate information\n- HTTP is a set of rules for how browsers and agents communicate with web servers\n- The basic process of HTTP is stateless, meaning that it does not remember a user's actions from one request to another\n- Uniform Resource Locators (URLs) identify the location of web pages, and include the protocol, hostname, path, and file name\n- Java provides libraries that can retrieve data from web servers using the URL and Reader/Stream mechanisms\n- Exception handling is essential when attempting to open and read data from a URL",
        "content":"\n\n\nAt its heart, network programming is all about how to properly transfer information between computers. As we discussed briefly when we first encountered type declarations in Java, a computer only ever deals with bits, so how is any particular set of 0s and 1s to be interpreted? What does an incoming bunch of bits imply, and how do I send the appropriate outgoing bunch of bits? That's what network protocols are all about. With the internet, there are multiple layers of how to handle bits, to gain increasing reliability (in case of misread bits, dropped bits or entire messages, etc.). You'll have to take the networking course to get into that; here we're just going to look at a high level, provided by web-based protocols.\n\nA key component of the web is HTTP, the HyperText Transfer Protocol, which is a set of rules for how browsers (and other agents on your machine) communicate with web servers. For example, your browser might ask the Dartmouth web server \"get /~reg/index.html\"; and then the web server responds with the hypertext for that page. Your browser would then notice that there are some images referenced in there, and ask the server for them.  Note that the basic process is stateless (doesn't remember you from one request\nto the next). Cookies, anyone?\n\nThe URL (Uniform Resource Locator) is the global identity of the page you want; e.g. http://www.dartmouth.edu/~reg/index.html\n\n http: — the protocol (how to obtain the document)\n www.dartmouth.edu — the hostname (which machine has it)\n ~reg/ — the path (where on that machine the document is)\n index.html — the file name (if absent, often assumed to be index.html or index.html)\n\n\nJava provides libraries that let us get from a web server, within a program. Here's a little self-referential program that gets this page.\n\n[WWWGet.java]import java.net.*;\nimport java.io.*;\n\npublic class WWWGet {\n\tpublic static void main(String[] args) throws Exception {\n\t\t// Open a stream reader for processing the response from the URL\n\t\tURL url = new URL(\"http://www.cs.dartmouth.edu/~albertoq/cs10/notes21.html\");\n\t\tSystem.out.println(\"*** getting \" + url);\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n\t\t// Read lines from the stream\n\t\tString line;\n\t\twhile ((line = in.readLine()) != null) {\n\t\t\tSystem.out.println(line);\n\t\t}\n\t\tin.close();\n\t\tSystem.out.println(\"*** done\");\n\t}\n}\n\nThe Reader/Stream mechanism for reading data works like we've done previously with files; the difference here is that the file is served up over the web, rather than loaded from your own machine. We create a new InputStreamReader that will get its input from the web server's response for the URL we provide. \n\nAs with files, trying to open and read from a URL can raise exceptions. \nAn exception-handling version of our previous buck-passing program: WWWGetTry.java. The handlers for the exceptions from creating the URL and the reader are at the bottom. We then have a try-within-a-try for reading (boy would Yoda be displeased — do or do not, there is no try), because we want to close the stream no matter what. Note that the stream closing itself can throw an exception, which is handled by the same catcher as for opening. Whew.\n\n\n"
    },
    "section4":{
        "id":4,
        "length":212,
        "title":"<title>CS 10 | Problem solving</title>\n",
        "overview":"Title: Java Tutorials on Graphical User Interface, Web Services and Processing XML\n\nOverview: This content covers Java tutorials on Graphical User Interface using Swing, getting information from the web using Java IO, web services, processing XML using JAXP and DOM techniques, Java notes and a finished product developed using Flickr API.\n\nHighlights:\n- Detailed Java tutorials on developing graphical user interfaces using Swing \n- How to get information from the web using Java IO\n- Overview of web services and its implementation in Java\n- Tutorial on processing XML using JAXP and DOM techniques\n- Code files for FlickrSearchJSON.java, FlickrSearchXML.java, FlickrSearchCore.java, ProcessXML.java, json-simple-1.1.1.jar, WWWGet.java, WWWGetTry.java\n- Instruction on how to install json-simple-1.1.1.jar as an external JAR \n- Slides from class on AQL and TJP.",
        "content":"\n\n\n Graphical user interface [Java tutorials on Swing]\n Getting stuff from the web [Java tutorial on IO]\n Web services\n Processing XML [Java tutorials on JAXP, particularly DOM]\n The finished product\n Java notes\n\n\nAll the code files for today: FlickrSearchJSON.java; FlickrSearchXML.java; FlickrSearchCore.java; ProcessXML.java; json-simple-1.1.1.jar; WWWGet.java; WWWGetTry.java\nNote: you need to download json-simple-1.1.1.jar and install it as an external JAR (as you did for the opencv files) to run FlickrSearchJSON.java.  Otherwise you can run FlickrSearchXML.java without installing the JAR.  The XML version does the same as the JSON version, but exchanges data with Flickr via XML instead of JSON. \n\nSlides from class (Section 12 - AQL)\n\nSlides from class (Section 2 - TJP)\n\n\n"
    },
    "section12":{
        "id":12,
        "length":225,
        "title":"<title>CS 10 | Problem solving</title>\n",
        "overview":"Title: Interpreting XML Responses from Web Services\n\nOverview: This article discusses how to interpret XML responses from web services and gives an example of a Flickr-based photo search application. It explains how XML represents data, and provides code to read the XML file into a representation that can be handled with a program.\n\nHighlights:\n- XML is a standard way of encoding data in a way that a program can interpret.\n- XML represents data by wrapping it with tags that give meaning to each piece and can be nested with inner parts being components of the outer parts.\n- An XML tag can also have a set of name-value attributes that give particular details.\n- To interpret XML responses, we need to know how to interpret the tags and their relationships to each other.\n- This article provides an example of interpreting an XML response from a Flickr-based photo search application using the document object model (DOM) approach.\n- The code in this article can be used to read the XML file into a representation that can be handled with a program and extract the URLs for photo elements.",
        "content":"\n\n\nSo now we've handled sending parameters to a web service; how do we get a response back that we can interpret? There are a number of approaches to encoding data in a way that a program could interpret it. One standard way is XML (eXtensible Markup Language), which is related to and much like HTML (HyperText Markup Language) in that they are both languages (sets of syntax and grammar rules) describing how to represent something. For HTML, that's hypertext; for XML, it's basically anything.\n\nXML represents data by wrapping it with tags that give some meaning to each piece. The tags can be nested, with the inner parts being components of the outer parts. A tag can also have a set of name-value attributes that give particular details (without going to the trouble of nesting them, since they're unique). A simple example:\n<enrollment>\n <course department=\"CS\" number=\"1\" term=\"18W\">\n  <student name=\"Alice\" year=\"20\" />\n  <student name=\"Bob\" year=\"19\" />\n  <student name=\"Charlie\" year=\"18\" />\n </course>\n <course department=\"CS\" number=\"10\" term=\"18W\">\n  <student name=\"Delilah\" year=\"19\" />\n  <student name=\"Elvis\" year=\"00\" />\n  <student name=\"Flora\" year=\"20\" />\n </course>\n</enrollment>Note that tags are enclosed with angle brackets (< ... >) and must come in properly nested pairs (start tag <name> ... end tag </name>;). A start tag can include attributes. If there's nothing to be nested inside an element, the tag can be self-closing, with a slash at the end of the start tag: <name/>.\n\nTo do something with XML, we have to know how to interpret the tags and what their relationships are to each other. That's obviously problem-specific. We're focusing here on a Flickr-based photo search application. We'll give Flickr a query describing the photos we're interested in, and it will return information about the photos that meet our criteria. The Flickr API documentation describes the format for different types of queries; we're doing a standard photo search here. \n\nFortunately the XML is pretty simple. An example (from a search for Dartmouth images, of course): flickr-dart.xml Actually, that's a hand-edited version of what Flickr gave back, as the original included an ampersand in \"Dev & The Cataracs\", which is a no-no in XML. It caused me some pain when writing code to process this, and as you'll see, I just did something simple (aka \"gross hack\") to deal with it.\n\nSo what can we do with XML? For our application, we want to actually pull down the images (we could also label them with their titles, etc., but I'll leave that for you to do on your own, if you're so interested). The Flickr URL documentation says that we can access a photo with a URL of this form:\nhttp://farm{farm-id}.staticflickr.com/{server-id}/{id}_{secret}.jpgSo for example, the fourth image in our XML file (Baker) has this URL:\nhttp://farm3.staticflickr.com/2622/3840099142_fb08d49e3a.jpg.\nLet's write a program to pull the URLs from the XML file. We need an ability to read the XML file into a representation we can handle with a program. Java provides numerous XML parsing libraries. Here I'll use the document object model (DOM) approach, in which we directly build a document structure mirroring the nested structure in the XML file. (If you ever explore your HTML through a power-user tool on your browser, that's the same idea.) The DOM gives us the ability to search for elements with a specific tag name and get their attributes (among many other things; e.g., navigating the nesting structure). So we can find the photos and build the URLs from the attributes as illustrated above.\n\nThe code: ProcessXML.java. Save flickr-dart.xml in a folder called \"inputs\". We start by pulling the XML file into one big String. We read the individual lines, using the same approach we've seen before, and concatenate them together. Along the way, we replace ampersands with pluses, the gross hack I mentioned. Then there's quite a bit of boilerplate to parse the XML string, due to the power and generality of the mechanism. Finally, we piece together the URLs for the photo elements as described. I had to write an extra little piece of code to look up the attribute of a given name and return its value, just by marching down the list of attributes and seeing which one matches.\n\n\n"
    }
}